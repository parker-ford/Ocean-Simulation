#include "UnityCG.cginc"
#include "../Includes/common.cginc"
#include "../Includes/complex.cginc"
#include "../Includes/noise.cginc"

#pragma kernel CS_InitializeSpectrum
#pragma kernel CS_UpdateSpectrum
#pragma kernel CS_Assemble

RWTexture2D<float4> _InitialSpectrum, _WavesData;
RWTexture2D<float2> _SpectrumDxDz, _SpectrumDyDxy, _SpectrumDyxDyz, _SpectrumDxxDzz;
RWTexture2D<float4> _Displacement;

uint _L, _MapSize;
float _A, _WindSpeed, _Depth, _Lambda;
float2 _WindDirection;

float4 GaussianRandom(float2 uv){
    //TODO: Try sampling noise texture rather than generating
    float n0 = clamp(whiteNoise_2D(uv, 1), 0.001, 1.0);
    float n1 = clamp(whiteNoise_2D(uv, 1324), 0.001, 1.0);
    float n2 = clamp(whiteNoise_2D(uv, 46512), 0.001, 1.0);
    float n3 = clamp(whiteNoise_2D(uv, 798654), 0.001, 1.0);

    float u0 = 2.0 * PI * n0;
    float v0 = sqrt(-2.0 * log(n1));
    float u1 = 2.0 * PI * n2;
    float v1 = sqrt(-2.0 * log(n3));

    float4 rand = float4(v0 * cos(u0), v0 * sin(u0), v1 * cos(u1), v1 * sin(u1));

    return rand;
}

float Frequency(float k, float g, float depth)
{
	return sqrt(g * k * tanh(min(k * depth, 20)));
}

float2 PhillipsSpectrum(uint2 id){
    float deltaK = 2 * PI / _L;
    int nx = id.x - _MapSize / 2;
    int nz = id.y - _MapSize / 2;
    float2 k = float2(nx, nz) * deltaK;
    float kLength = length(k);
    float kLength2 = kLength * kLength;

    // if(kLength > 0.5){
    //     return float2(0,0);
    // }

    //TODO: implement low and high pass here
    float kAngle = atan2(k.y, k.x);
    float omega = Frequency(kLength, GRAVITY, _Depth);
    _WavesData[id.xy] = float4(k.x, 1.0 / kLength, k.y, omega);

    float L_ = (_WindSpeed * _WindSpeed) / GRAVITY;

    // float h0k = exp(-1 / pow(k * L, 2));
    // h0k /= (kLength2 * kLength2);
    // h0k *= _A;
    // h0k *= pow(dot(normalize(k) * normalize(_WindDirection)), 2);

    float h0k = clamp(sqrt(( _A / (kLength2 * kLength2))
    * pow(dot(normalize(k), normalize(_WindDirection)), 6.0)
    * exp(-(1.0/(kLength2 * L_ * L_)))
    * exp(-kLength2 * pow( _L / 2000.0, 2.0))) / sqrt(2.0), -4000.0, 4000.0);

    float h0kminus = clamp(sqrt (( _A / (kLength2 * kLength2))
    * pow(dot(normalize(-k), normalize(_WindDirection)), 6.0)
    * exp(-(1.0/(kLength2 * L_ * L_)))
    * exp(-kLength2*pow(_L / 2000.0, 2.0))) / sqrt(2.0), -4000, 4000);

    float4 rand = GaussianRandom(float2(id.xy) / (float)_MapSize);

    return rand.xy * h0k;


    
}

[numthreads(1,1,1)]
void CS_InitializeSpectrum (uint3 id : SV_DispatchThreadID)
{
    // float4 initialSpectrum = float4(0,0,0,0);
    // float2 h0k = 1.0/sqrt(2) 
    _InitialSpectrum[id.xy] = float4(PhillipsSpectrum(id.xy), 0, 0);
    // float4 rand = GaussianRandom(float2(id.xy) / (float)_MapSize);
    // _InitialSpectrum[id.xy] =  float4(rand.xy, 0, 0);
}

[numthreads(8,8,1)]
void CS_UpdateSpectrum(uint3 id: SV_DispatchThreadID)
{
    float4 wave = _WavesData[id.xy];
    float phase = wave.w * _Time.y;
    float2 exponent = float2(cos(phase), sin(phase));
    float2 h = ComplexMult(_InitialSpectrum[id.xy].xy, exponent) + ComplexMult(_InitialSpectrum[id.xy].zw, float2(exponent.x, -exponent.y));
    float ih = float2(-h.y, h.x);

    float2 displacementX = ih * wave.x * wave.y;
    float2 displacementY = h;
    float2 displacementZ = ih * wave.z * wave.y;

    float2 displacementX_dx = -h * wave.x * wave.x * wave.y;
    float2 displacementY_dx = ih * wave.x;
    float2 displacementZ_dx = -h * wave.x * wave.z * wave.y;

    float2 displacementY_dz = ih * wave.z;
    float2 displacementZ_dz = -h * wave.z * wave.z * wave.y;

    //Dx_Dz
    _SpectrumDxDz[id.xy] = float2(displacementX.x - displacementZ.y, displacementX.y + displacementZ.x);
    //Dy_Dxy
    _SpectrumDyDxy[id.xy] = float2(displacementY.x - displacementZ_dx.y, displacementY.y + displacementZ_dx.x);
    //Dyx_Dyz
    _SpectrumDyxDyz[id.xy] = float2(displacementY_dx.x - displacementY_dz.y, displacementY_dx.y + displacementY_dz.x);
    //Dxx_Dzz
    _SpectrumDxxDzz[id.xy] = float2(displacementX_dx.x - displacementZ_dz.y, displacementX_dx.y + displacementZ_dz.x);

    // float2 h = ComplexMult()
}

[numthreads(8,8,1)]
void CS_Assemble(uint3 id: SV_DispatchThreadID)
{
    float2 DxDz = _SpectrumDxDz[id.xy];
    float2 DyDxy = _SpectrumDyDxy[id.xy];
    float2 DyxDyz = _SpectrumDyxDyz[id.xy];
    float2 DxxDzz = _SpectrumDxxDzz[id.xy];

    _Displacement[id.xy] = float4(_Lambda * DxDz.x, DyDxy.x, _Lambda * DxDz.y, 1.0);
    // _Displacement[id.xy] = float4(DxDz, 0, 1.0);
}
